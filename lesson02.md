# Урок 2. Булева алгебра. Управляющие конструкции.

## Булевы переменные

Переменная типа `bool` может содержать только два значения: **True** или **False**, при чем это не строки, не числа, а именно понятия ложь и истина.

Для работы с булевыми переменными существует булева алгебра.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6c/George_Boole.jpg/267px-George_Boole.jpg)

## Булева алгебра (логические операторы)

Существуют следующие логические операторы:

* and  - И
* or   - ИЛИ
* xor  - Исключающее ИЛИ (подключается отдельно)
* not  - НЕ

not означает НЕ, и, будучи поставленным перед типом bool, меняет его значение на обратное, т.е. **`not True`** становится **`False`**,**`not False`** становится **`True`**

Далее приведена таблица, демонстрирующая работу операторов:

| Операторы  | 0 to 0| 0 to 1| 1 to 0 | 1 to 1|
|------------|:-----:|:-----:|:------:|:-----:|
| and        |   0   |   0   |    0   |   1   |
| or         |   0   |   1   |    1   |   1   |
| xor        |   0   |   1   |    1   |   0   |


## Оператор условия if

В python в отличие от множества других языков существует только один оператор условия `if -> elif -> else`

```python
print ("Give it to me!")
number = int(input())

if (number >= 100):
    print ("Thanks, man!")
elif ((number > 10) and (number < 100)):
    print ("OK :(")
else:
    print ("WHAAAAT????")

if (number > 1000):
    print ("!!!!WOOOOWWWW!!!")

```


Обратите внимание, мы впервые сталкиваемся с блоком операторов. Так же будет и у циклов, и у функций, и у классов, и у их методов, и так далее. блок операторов начинается со своего инициатора (например, сейчас это блок оператора if), после инициатора ставится двоеточие, затем все действия, которые программист хочет выполнять в рамках этого блока, он должен выполнять после одного дополнительного отступа. Если отступа не будет, python будет воспринимать это как код вне блока.

Есть возможность применять оператор if в нескольких вариантах. Ниже приведен список всех вариантов:

* if (условие) действие
* if (условие) (блок действий в несколько строк)
* if (условие) (блок действий в несколько строк) else действие
* if (условие) (блок действий в несколько строк) else (блок действий в несколько строк)
* if (условие) (блок действий в несколько строк) elif(условие) (блок действий в несколько строк) else действие
* if (условие) (блок действий в несколько строк) elif(условие) (блок действий в несколько строк) else (блок действий в несколько строк)

**Между if и else может быть сколько угодно elif.**

## Операторы сравнения и приоритеты операций

В отличии от языка С, в Python операторы сравнения имеют одинаковый приоритет.

Результатом сравнений является ответ типа `bool` - **`True`** или **`False`**.

В отличии от многих других языков, Python похволяет использовать цепочки операторов сравнения, т.е. классическое для программирования двойное сравнение может быть заменено цепочкой:

```python
>>> x = 5
>>> y = 10
>>> z = 15

>>> (x < y) and (y <= z)
True

>>> x < y <= z
True
```

К операторам сравнения относятся следующие:

```
"<"      - меньше 
">"      - больше
"=="     - равно
">="     - больше или равно
"<="     - меньше или равно
"!="     - не равно
"not"    - не является чем-то
"is"     - является тем же самым
"is not" - не является тем-же самым
"in"     - является частью чего-то
"not in" - не является частью чего-то
```

Последние четыре оператора нуждаются в дополнительном пояснении.

Оператор `is` проверяет, являются ли оба операнда одним и тем же объектом в памяти, тогда как простое сравнение на равенство `==` проверяет только на соответствие содержимого двух операндов, но не проверяет, являются ли они одним и тем же объектом.

```python
>>> l1 = [1, 2, 3]
>>> l2 = [1, 2, 3]
>>> l1 == l2
True
>>> l1 is l2
False
>>> l1 is not l2
True
```

Оператор **`in`** проверяет, включает ли операнд справа тот операнд, что слева:

```python
>>> 3 in l1
True
>>> 4 in l1
False
>>> 5 not in l1
True
```

## Альтернативный синтаксис if, замена тернарному оператору

Во многих языках программирования (С++, Java, PHP...) существуют тернарный оператор, т.е. специальный оператор условия, который возвращает один из двух результатов, в зависимости от того, выполняется его условие или нет. Выглядит он так:

```php
print ($input == 1) ? "One!" : "Not One!";
```

Тернарные операторы часто применяются, когда варианта всего два, так как такая запись короче аналогичного действия с if. Однако, к сожалению, можно встретить связку if-ов и тернарных операторов, которую совершенно невозможно прочесть. Другими словами, это не необходимая вещь в языке и она может стать причиной нечитаемого текста.

В python нет тернарного оператора, но есть возможность его имитировать при помощи if:

```python
test = True
result = 'Test is True' if test else 'Test is False'
# result = 'Test is True'
```

Это можно использовать с любыми функциями, как и с печатью:

```python
test = True
print ('ttt' if test else 'fff') # выведет ttt
```

## Особенности сравнения объектов

В языке Python все является объектом. Когда мы говорим о числе, строке, функции. классе, списке и т.д. - мы говорим об объекте.

Python считает, что если объект не пуст, он True, а не False. False - это собственно сам False, 0 и пустая строка. Таким образом если нам необходимо сравнить строку с пустой строкой, или число с нулем, а так же узнать, является ли пустым тот или иной объект, вместо того, чтобы писать условия в стиле старых языков:

```python
if s !='':
    pass
    
if 8 % 2 != 0:
    pass
```

можно слегка их сократить:

```python
if s:
    pass
    
if 8 % 2:
    pass
```

Это значительно сокращает и упрощает код.

## Еще одна альтернатива тернарному оператору

Применение **and** к нескольким выражениям не просто возвращает True или False. Оно возвращает первое false-выражение, либо последнее из выражений, если все они true.

К примеру, если мы проверяем в if условие:

```python
a = 11
if a>10 and a < 20:
    pass
```

то, что and вернет нам, будет результатом вычисления и будет True или False, и нам это никак не поможет. Этой возможностью вообще нет смысла пользоваться в рамках if.
Аналогично, операция or возвращает первое true-значение, либо последнее, если ни одно из них не true.

Используя вышеописанную особенность python, можно реализовать тернарный оператор еще более оригинальным образом:

```python
test = True
result = test and 'Test is True' or 'Test is False'
```

В нашем случае test = True, т.е. and его пропускает и возвращает нам последнее из истинных значений, с которым работал, т.е. выражение 'Test is True' or 'Test is False'. Or возвращает первое встреченное true выражение, ему больше ничего не интересно. Если заменить строки приблизительным смыслом и использовать псевдокод, получим что-то вида:

```python
result = true1 and true2 or true3
result = true2 or true3
result = true2
```

Что касается приоритета операций, not приоритетнее and, and приоритетнее or. Т.е. сначала выполняется not, потом and, потом or. Приоритеты всех операций ищите в ссылках.



## Практика

1. Проверить, является ли введеное число четным.
2. Проверить, является ли число нечетным, делится ли на три и на пять одновременно, но так, чтобы не делиться на 10.
3. Ввести число, вывести все его делители.
4. Ввести число, вывести его разряды и их множители.

## Ссылки

[Приоритеты операций в Python](https://docs.python.org/3/reference/expressions.html#operator-precedence)

[Чейнинг операторов сравнений](https://www.geeksforgeeks.org/chaining-comparison-operators-python/)

[Домашка](hw02.md)

[Следующий урок](lesson03.md)
