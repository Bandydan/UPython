# Урок 5. Функції

![](images/functions.jpg)

## Термінологія на урок:

**Функцією** називається окремий блок програми. Він може мати ім'я, він може приймати аргументи, з якими потім працюватиме, і він може повертати результат своєї роботи.

**Параметрами** функції називаються спеціальні змінні, які прийматимуть конкретні значення під час виклику цієї функції. Вони також є локальними змінними всередині цієї функції, які приймають аргументи як значення. Альтернативна назва - формальні параметри.

**Аргументами** або фактичними параметрами називаються змінні (вирази, літерали та інше), передані в функцію при виклику. По суті, аргументи – це джерело реальних значень параметрів функції за її виклику.

**Літерал** - фактичне значення, яке записується у змінну чи передається у функцію. Наприклад, у записі `x = 1` літералом є 1.

### Створення, або оголошення функції

В Python функція створюється наступним чином:

```python
def say_hello():
    return "Hello"
```

**Найважливіші елементи функції:**

- ключове слово **`def`** свідчить, що далі буде функція
- після def слідує назва функції, наведена вище називається **`say_hello`**
- потім йдуть дужки з параметрами функції
- після дужки йде двокрапка. Як ми знаємо, двокрапка в Python означає, що далі буде якийсь блок коду, виділений відступами. У разі умови це блок умови, тіло умови, у випадку з циклом - тіло циклу, у випадку з функцією - тіло функції або код функції
- ключове слово **`return`** використовується в тілі функції, щоб завершити роботу функції та повернути її результат. Якщо не написати **`return`**, функція поверне **`None`**. Гарним тоном буде повертати якесь значення явно
- результат роботи функції – результат виконання функції, який вона повертає. У наведеному прикладі результатом роботи функції буде рядок "Hello", з функції він повернеться завдяки ключовому слову **`return`**.

У Python прийнято тіло функції, як і тіло будь-якого блоку, виділяти відступом у 4 пробіли.

![](images/pain.jpg)

**Все, що ми обговорюємо - лише створення функції, але не використання її. Для використання функції її потрібно викликати.**

### Виклик функції (function call)

Створену (оголошену) функцію необхідно викликати, щоб вона виконала своє завдання. Доки функція не викликана, вона марна і нічого не робить.

Якщо просто написати функцію і викликати її, ми не побачимо результат, що повертається. Він повернеться, але після цього загубиться. Для того, щоб цей результат не втратити, його потрібно передати в роботу іншої функції, зберегти у змінну або будь-яким іншим чином обробити. Наприклад, помістимо її в функцію **`print`** як аргумент.

Викликаємо нашу функцію **`say_hello:`**

```python
print(say_hello()) # Hello
```
Іноді, особливо у великих проектах, буває так, що програміст створив функцію, але поки ще не придумав її код. Зазвичай у такому випадку замість коду вставляється команда `pass` чи `...`, які інтерперетатор просо пропускає. Але у цьому випадку, якщо ви пізніше викличете функцію без коду, вона нічого не виконає, а ви не будете розуміти у чому проблема. Тому вважається хорошим тоном заповнювати пусті функції настумпним кодом:

```python
def func():
    raise NotImplementedError('Code of func() is missing')
```

У цьому випадку при виклику не імплементованої функції, у консоль буде виведено повідомлення про помилку з відповідним текстом і вам буде набагато легше зрозуміти у чому проблема.


### Параметри та аргументи функції

Функції також можуть приймати параметри:

```python
def plus(num1, num2):
    result = num1 + num2
    return result
```

Тут **`num1`** і **`num2`** - параметри функції **`plus`**.

#### Аргументи чи параметри? Локальні та глобальні змінні

При створенні функції ви описуєте параметри, під час виклику - передаєте аргументи. Значення аргументів потрапляють у параметри, всередині функції - це параметри або просто локальні змінні.

Щодо локальних та глобальних змінних:

```python
test_var = "Global value"

def use_global():
	print(f'`use_global` function has: {test_var}\n')

def use_local():
	test_var = "Local value"
	print(f'`use_local` function has: {test_var}\n')

def change_global():
	global test_var
	test_var += " and local value"
	print(f'`change_global` function has: {test_var}\n')


print(f'Global variable equals to {test_var}\n')
use_global()
print(f'Global variable equals to {test_var}\n')
use_local()
print(f'Global variable equals to {test_var}\n')
change_global()
print(f'Global variable equals to {test_var}\n')

```

У Python, якщо ви декларуєте параметри, ви зобов'язані передати відповідні аргументи, інакше отримаєте помилку. Викликаємо нашу функцію plus з двома числами-аргументами - **10** і **5**:

```python
ten = 10
five = 5

plus(ten, five)
# returned 15

plus(10, 5)
# returned 15

```
У момент виконання функції параметри `num1` і `num2` приймуть значення `10` та `5` відповідно.  

Також в python можна передавати аргументи не послідовно, але з явною вказівкою аргументу та відповідністю аргументу переданому значенню

```python
plus(num1=10, num2=5)

plus(num2=5, num1=10)
```

### Види параметрів функції


```python
def func(positional, keyword=value, *args, **kwargs)
    pass

```

У Python можна розрізнити 4 види параметрів функції:

1. **Позиційні аргументи** є обов'язковими й не мають значень за замовчуванням.
2. **Аргументи з ключовим словом** необов'язкові та мають значення за замовчуванням.
3. **Список із довільною кількістю аргументів** необов'язковий та не має значень за замовчуванням.
4. **Словник із довільною кількістю аргументів** із ключовим словом необов'язковий й не має значень за замовчуванням.

```python

def test(a, b=10, *c, **d):
    summa = a + b
    if c:
        summa += sum(c)
    if d:
        summa += sum(d.values())
    
    return summa

print(test(15))                         # 25
print(test(15, 5))                      # 20
print(test(15, 5, 1, 2, 3))             # 26
print(test(15, 5, 1, 2, 3, x=10, y=20)) # 56
```

### Функція як тип даних

Все в Python є об'єктом. Функції не виділяються і також є об'єктами. Як і будь-які інші типи даних, функції можна зберігати в змінних, передавати аргументами до інших функцій і зберігати в словниках, списках і кортежах.

Приклад передачі функції як параметр:

```python
def run_operation(num1, num2, operation):
    return operation(num1, num2)

def plus(num1, num2):
    return num1 + num2

minus = lambda num1, num2: num1 - num2

run_operation(10, 5, plus)  # 15
run_operation(10, 5, minus) # 5
```

Зберігання функції у словнику:

```python

functions_dict = {
    'plus': plus,
    'minus': minus
}

def operation(num1, num2, func_dict, func_name):
    return func_dict[func_name](num1, num2)

operation(2, 3, function_dict, 'plus')
```

### Лямбда вирази

У python немає анонімних функцій в їх звичайному вигляді, але є лямбда-вирази в один рядок, які можна використовувати замість невеличких анонімних функцій.

![](images/lambdas.png)

Вони мають наступний синтаксис:

- ключове слово `lambda`
- потім перелік параметрів
- потім двокрапка, яка відділяє перелік параметрів від своєрідного тіла лямбди
- після двокрапки йде вираз, який є однорядковим тілом лямбди, повертає своє значення як результат роботи функції та не потребує `return`

`lambda arguments : expression`

Приклади:
```python
lambda age: 'Senior' if age > 55 else 'Adult'

(lambda x, y: x + y)(2, 3)
```
Після того, як лямбда-вираз оголошено, він може бути використаний у таких випадках:

    1.як функція. Це випадок, коли лямбда-вираз присвоюється деякому імені. Потім за цим іменем відбувається виклик лямбда-виразу;
    2.як елемент (літерал) кортежу чи списку;
    3.як елемент (літерал) словника, який за вимогою виконує деяку дію. У цьому випадку формується так звана таблиця переходів.

Між оголошенням функції та використанням лямбда-виразів та функцій існують наступні відмінності:

    1.лямбда-вираз оголошується з допомогою ключового слова lambda, функція оголошується з допомогою ключового слова def;
    2.лямбда-вирази – це вирази, def – це інструкції. Це означає, що лямбда-вираз може бути використаний там де не допускається використання def: всередині літералів чи викликах функцій;
    3. лямбда-вираз містить тільки один вираз, який повертається. Результат обчислення виразу є результатом лямбда-виразу. Для повернення результату з лямбда-виразу не потрібно використовувати інструкцію return;
    4.на відміну від оголошення функцій (def) лямбда-вирази призначені для обчислення більш простих фрагментів коду порівняно з функціями;
    5.програмний код лямбда-виразу формується у вигляді одного рядка. Програмний код функції може містити довільну кількість рядків.

Також у лямбда-виразах не можна розміщувати команди управління (if, while, for). Якщо спробувати розмістити в одному рядку оператор while в тілі лямбда-виразу, то інтерпретатор Python видасть помилку “Invalid syntax” як показано нижче:

>>>Тут видає помилку: "Invalid syntax"
```python
lmbd = lambda n: while n>0: n=n-1
print("lmbd = ", lmbd)
```

Те саме стосується й інших керуючих конструкцій. 

Слід відмітити, що деякі програмісти після знайомства з лямбда-функцією починають нею зловживати, використовуючи її навіть тоді, коли можна обійтись простими обчисленнями. Такий стиль програмування призводить до переускладення коду і ускладнує його супровід.

### Функції вищого порядку на прикладі Map, Filter, Reduce

Вже знайома нам функція **`map`** приймає два аргументи: функцію та ітератор, наприклад, список, та застосовує функцію до кожного елемента списку:

```python
string_numbers = ['1', '2', '3', '4', '5']
new_list = list(map(int, string_numbers))

print(new_list)
#  [1, 2, 3, 4, 5, 6, 7]
```

Ще приклад:

```python
def my_square(num):
    return num ** 2

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
squared_numbers = list(map(my_square, numbers))

print(squared_numbers)
# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

Так само в будь-яку функцію вищого порядку можна передавати не тільки вбудовану функцію, але й самописну, й лямба-вираз.

Функція `filter` приймає два аргументи: якою функцією фільтрувати ітератор та й сам ітератор. Функція має повертати `True` або `False`. За допомогою цієї функції з першого аргументу `filter` створює лінивий ітератор з тих значень вхідного ітератора, яки пройшли перевірку.

Приклад:

```python
filter(lambda x: x % 2, range(10))
```

```python
>>> print(list(filter(lambda x: x % 2, range(10))))
[1, 3, 5, 7, 9]
```

Функція `reduce` за допомогою свого першого параметра - функції, зводить свій другий параметр - ітератор, до одного значення. Для використання функції потрібно підключати бібліотеку `functools`. Приклад роботи:

```python
>>> from functools import reduce
>>> reduce(lambda x, y: x+y, range(10))
45
```
## Практика

#### Завдання 1
Написати 2 функції.
Перша функція прийматиме рядок та приводитиме його до нижнього регістру.
Друга функція прийматиме рядок та приводитиме його до верхнього регістру.

Головна програма має застосовувати обидві функції до списку рядків за допомогою `map`, для кожного з рядків, та друкувати результат.

#### Завдання 2

Написати функцію, яка буде підносити число у квадрат. Написати другу, яка буде перевіряти, чи є число простим.
Потрібно видрукувати в головній програмі квадрати усіх простих чисел зі списку від 0 до 50 за допомогою `map`

#### Завдання 3
Візьміть файл, в якому є багато англійських слів у рядках. Порахуйте частоту зустрічі кожного слова та видрукуйте відсортовано.


## Посилання

[**ZIP**](https://tproger.ru/translations/implementing-zip-list-comprehensions/)

[**Map, Zip, Lambda**](http://ninjaside.info/blog/ru/funkcii-map-i-zip-i-lambda-python/)

[**Lambda article**](https://realpython.com/python-lambda/)

[Домашка](hw05.md)
